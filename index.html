<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PDF Annotator with Japanese Marker Decode</title>
  <!-- pdf-lib -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <!-- fontkit for custom TTF/OTF embedding -->
  <script src="https://unpkg.com/@pdf-lib/fontkit/dist/fontkit.umd.min.js"></script>
</head>
<body>
  <h2>PDF Annotator Test (Decode & Embed JP from <!s>...<?e>)</h2>
  <input type="file" id="file-input" accept="application/pdf" />
  <button id="save-btn">Save Annotated PDF</button>
  <div id="log" style="margin-top:8px;font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto;">
    Load a PDF, then click Save. This will decode markers like <code>&lt;!s&gt;\u3053\u306E&lt;?e&gt;</code> and embed Japanese text invisibly.
  </div>

  <script>
    let pdfBytes = null;

    const MARK_RE = /<!s>([\s\S]*?)<\?e>/g;

    // \uXXXX â†’ actual Unicode char
    function decodeEscapes(s) {
      return String(s || '').replace(/\\u([0-9a-fA-F]{4})/g, (_, h) =>
        String.fromCharCode(parseInt(h, 16))
      );
    }

    function log(msg) {
      document.getElementById('log').textContent = msg;
    }

    document.getElementById('file-input').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      pdfBytes = await f.arrayBuffer();
      log(`Loaded: ${f.name} (${(f.size/1024/1024).toFixed(2)} MB). Click "Save Annotated PDF".`);
    });

    document.getElementById('save-btn').addEventListener('click', async () => {
      if (!pdfBytes) return alert('Load a PDF first!');
      try {
        log('Scanning markersâ€¦');
        const overlays = await collectOverlays(pdfBytes);
        const total = overlays.reduce((n, arr) => n + arr.length, 0);
        log(`Found ${total} markers. Embedding Japanese text (invisible)â€¦`);
        const blob = await generateAnnotatedPDF(pdfBytes, overlays);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'annotated.pdf';
        a.click();
        log(`Done. Embedded ${total} decoded items.`);
      } catch (err) {
        console.error(err);
        alert('Error: ' + err.message);
        log('Error: ' + err.message);
      }
    });

    // Use pdf.js to find marker items and positions (x, y, size) per page.
    async function collectOverlays(bytes) {
      const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
      const n = pdf.numPages;
      const perPage = [];

      for (let i = 1; i <= n; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1 }); // PDF points
        const H = viewport.height;

        const textContent = await page.getTextContent({ disableCombineTextItems: false });
        const items = textContent.items || [];
        const list = [];

        for (const it of items) {
          const s = it.str || '';
          if (!s || s.indexOf('<!s>') === -1) continue;

          // Combine transforms: viewport * item
          const m = pdfjsLib.Util.transform(viewport.transform, it.transform); // [a,b,c,d,e,f]
          const x = m[4];
          const yTop = m[5];
          const size = Math.hypot(m[2], m[3]) || Math.abs(m[3]) || 12;

          let mRes;
          MARK_RE.lastIndex = 0;
          while ((mRes = MARK_RE.exec(s)) !== null) {
            const payload = String(mRes[1] || '');
            list.push({
              text: decodeEscapes(payload), // Japanese
              x: x,
              y: H - yTop - size,           // convert to pdf-lib baseline
              size: size
            });
          }
        }

        perPage.push(list);
        page.cleanup();
      }

      return perPage;
    }

    // Build new bytes with decoded text drawn invisibly using your JP font.
    async function generateAnnotatedPDF(bytes, perPage) {
      const pdfDoc = await PDFLib.PDFDocument.load(bytes);
      pdfDoc.registerFontkit(fontkit);

      // ðŸ‘‰ Your local JP font file placed next to this HTML:
      const fontUrl = './NotoSansJP-Regular.ttf';
      const fontBytes = await fetch(fontUrl).then(r => {
        if (!r.ok) throw new Error('Failed to fetch NotoSansJP-Regular.ttf. Place it next to the HTML.');
        return r.arrayBuffer();
      });
      const jpFont = await pdfDoc.embedFont(fontBytes, { subset: true });

      const pages = pdfDoc.getPages();
      for (let i = 0; i < perPage.length; i++) {
        const page = pages[i];
        const items = perPage[i] || [];
        for (const it of items) {
          page.drawText(it.text, {
            x: it.x,
            y: it.y,
            size: it.size,
            font: jpFont,                // fixes WinAnsi error
            color: PDFLib.rgb(0, 0, 0),
            opacity: 0                   // invisible but searchable/selectable
          });
        }
      }

      const out = await pdfDoc.save({ useObjectStreams: false });
      return new Blob([out], { type: 'application/pdf' });
    }
  </script>

  <!-- pdf.js (load last) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    // Worker for pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js";
  </script>
</body>
</html>
